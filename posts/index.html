<!doctype html><html><head><title>Posts</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="ie=edge"><link rel=stylesheet href=/css/bootstrap.min.css><link rel=stylesheet href=/css/layouts/main.css><link rel=stylesheet href=/css/navigators/navbar.css><link rel=stylesheet href=/css/plyr.css><link rel=stylesheet href=/css/flag-icon.min.css><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Muli:wght@300;400;500;600"><link rel=stylesheet href=/fontawesome/css/all.min.css><link rel=icon type=image/png href=/images/bio_hub4ccc2cf31de01119e0515bbf77fd96c_51578_42x0_resize_q75_box.jpg><meta property="og:title" content="Posts"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://uh-zz.github.io/posts/"><meta property="og:updated_time" content="2022-07-05T18:07:06+09:00"><link rel=stylesheet href=/css/layouts/list.css><link rel=stylesheet href=/css/navigators/sidebar.css><link rel=stylesheet href=/css/style.css></head><body data-spy=scroll data-target=#TableOfContents data-offset=80><div class="container-fluid bg-dimmed wrapper"><nav class="navbar navbar-expand-xl top-navbar final-navbar shadow"><div class=container><button class="navbar-toggler navbar-light" id=sidebar-toggler type=button onclick=toggleSidebar()>
<span class=navbar-toggler-icon></span></button>
<a class=navbar-brand href=/><img src=/images/bio_hub4ccc2cf31de01119e0515bbf77fd96c_51578_42x0_resize_q75_box.jpg alt=Logo>
small land</a>
<button class="navbar-toggler navbar-light" id=toc-toggler type=button onclick=toggleTOC()>
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse lang-selector" id=top-nav-items><ul class="navbar-nav ml-auto"></ul></div></div><img src=/images/bio_hub4ccc2cf31de01119e0515bbf77fd96c_51578_42x0_resize_q75_box.jpg class=d-none id=main-logo alt=Logo>
<img src=/images/bio_hub4ccc2cf31de01119e0515bbf77fd96c_51578_42x0_resize_q75_box.jpg class=d-none id=inverted-logo alt="Inverted Logo"></nav><section class=sidebar-section id=sidebar-section><div class=sidebar-holder><div class=sidebar id=sidebar><form class=mx-auto method=get action=/search><input type=text name=keyword placeholder=Search data-search id=search-box></form><div class=sidebar-tree><ul class=tree id=tree><li id=list-heading><a href=/posts data-filter=all>Posts</a></li><div class=subtree><li><a href=/posts/introduction/ title=Introduction>Introduction</a></li><li><i class="fas fa-plus-circle"></i><a href=/posts/category/>Category</a><ul><li><i class="fas fa-plus-circle"></i><a href=/posts/category/aws/>AWS</a><ul><li><a href=/posts/category/aws/2020/06/dynamo-only-sortkey-without-partionkey/ title="DynamoDB のソートキーだけで絞り込みたいとき">DynamoDB のソートキーだけで絞り込みたいとき</a></li></ul></li><li><i class="fas fa-plus-circle"></i><a href=/posts/category/computer-science/>Computer Science</a><ul><li><a href=/posts/category/computer-science/2020/11/thread-and-concurrency/ title=スレッドと並行処理>スレッドと並行処理</a></li><li><a href=/posts/category/computer-science/2020/09/process-management/ title=プロセス管理>プロセス管理</a></li><li><a href=/posts/category/computer-science/2020/10/memory-management/ title=メモリ管理>メモリ管理</a></li></ul></li><li><i class="fas fa-plus-circle"></i><a href=/posts/category/development/>Development</a><ul><li><a href=/posts/category/development/2020/08/agile-software-development/ title=アジャイル開発>アジャイル開発</a></li><li><a href=/posts/category/development/2021/03/pragmatic-programmer/ title=達人プログラマーとは>達人プログラマーとは</a></li></ul></li><li><i class="fas fa-plus-circle"></i><a href=/posts/category/go/>Go</a><ul><li><a href=/posts/category/go/2020/07/compare-sort-aligorithm/ title=ソートアルゴリズム>ソートアルゴリズム</a></li><li><a href=/posts/category/go/2020/07/spherical-trigonometry/ title=球面三角法による２点間の距離計算>球面三角法による２点間の距離計算</a></li></ul></li><li><i class="fas fa-plus-circle"></i><a href=/posts/category/inputs/>Inputs</a><ul><li><a href=/posts/category/inputs/2022/07/ title=2022/07>2022/07</a></li></ul></li><li><i class="fas fa-plus-circle"></i><a href=/posts/category/oss/>OSS</a><ul><li><a href=/posts/category/oss/2020/08/semantic-versioning/ title="Semantic Versioning">Semantic Versioning</a></li></ul></li><li><i class="fas fa-plus-circle"></i><a href=/posts/category/security/>Security</a><ul><li><a href=/posts/category/security/2021/01/oauth/ title="OAuth について">OAuth について</a></li></ul></li><li><i class="fas fa-plus-circle"></i><a href=/posts/category/system-design/>System Design</a><ul><li><a href=/posts/category/system-design/2020/12/principles-of-the-systems-architecture/part1/ title=システム設計-part1->システム設計-part1-</a></li><li><a href=/posts/category/system-design/2020/12/principles-of-the-systems-architecture/part2/ title=システム設計-part2->システム設計-part2-</a></li><li><a href=/posts/category/system-design/2020/12/principles-of-the-systems-architecture/part3/ title=システム設計-part3->システム設計-part3-</a></li></ul></li><li><i class="fas fa-plus-circle"></i><a href=/posts/category/look-back-on/>振り返り</a><ul><li><a href=/posts/category/look-back-on/2021/ title=2021年>2021年</a></li><li><a href=/posts/category/look-back-on/2022/05/31/go-to-the-teikyo-university/ title=2022年>2022年</a></li></ul></li></ul></li></div></ul></div></div></div></section><section class=content-section id=content-section><div class="content container-fluid" id=content><div class="container-fluid post-card-holder" id=post-card-holder><div class=post-card><a href=/posts/category/inputs/2022/07/ class=post-card-link><div class=card><div class=card-head><img class=card-img-top src=/images/default-hero.jpg alt="Hero Image"></div><div class=card-body><h5 class=card-title>2022年07月に読んだ記事とか本とか</h5><p class="card-text post-summary">はじめに 読んだ記事とか本のリンクを張っておきます
読んだ記事 アーキテクトに求められるマインドとは / mindset for an architect
Re: スクラム開発チームと業務委託エンジニアの相性が最悪だと思っている
Spring で快適な DB 疎通ユニットテストライフを送りたい
「“楽しくないけどお金のためにやる人”はやはり伸びない」まつもとゆきひろ氏が説く“プログラマーに向いている人”
「ノーコードによって仕事が奪われるイメージはない」まつもとゆきひろ × 高橋直大 × 楠正憲が語る、これからのプログラマーの仕事
読んだ本 自分に気づく心理学-加藤 諦三(著)
Lean と DevOps の科学[Accelerate] テクノロジーの戦略的活用が組織変革を加速する (impress top gear)-Nicole Forsgren Ph.D. (著), Jez Humble (著), Gene Kim (著), 武舎広幸 (翻訳), 武舎るみ (翻訳)
JABEE 対応 技術者倫理入門-小出 泰士(著)
やさしく学べる基礎物理-基礎物理教育研究会(編集)</p></div><div class=card-footer><span class=float-left>July 5, 2022</span>
<a href=/posts/category/inputs/2022/07/ class="float-right btn btn-outline-info btn-sm">Read</a></div></div></a></div><div class=post-card><a href=/posts/category/look-back-on/2022/05/31/go-to-the-teikyo-university/ class=post-card-link><div class=card><div class=card-head><img class=card-img-top src=/posts/category/look-back-on/2022/05/31/go-to-the-teikyo-university/hero.png alt="Hero Image"></div><div class=card-body><h5 class=card-title>【通信教育課程】帝京大学理工学部情報科学科に編入学しました</h5><p class="card-text post-summary">はじめに 表題の通り、今年の 4 月から帝京大学理工学部情報科学科の通信教育課程に 2 年次編入しました。
そもそもの経緯と入るまでの話、入って 1 ヶ月経過した後の所感をまとめておきたいと思います。
きっかけ 大学進学について 通信制大学へ進学したいと思ったのは今年に入ってからではなく、ここ 2 年くらい検討していました。
当初は理工系ではなく、社会学/哲学に興味があり、その方面の勉強がしたいと漠然と考えていました。
ただ 2 年の間、大学への入学を躊躇してたのは以下の理由がありました。
通信制大学の卒業が難しい、また卒業率が低いといった情報を見て腰が重かった 働きながら時間が取れない、平日のフルタイムかつ出社している場合、早朝か、仕事から帰ってきて勉強時間を確保する必要が出てくるので、リモートできないと厳しい とりあえず入門書を買って積んでおけば自分で勉強できるし、進学しなくてもいいのでは？と諦めムードを出していた 以上の理由から悩んでは忘れるを一人繰り返しては日々を過ごしていました。
キャリアについて考えるようになった そんな中、昨年末に以下の記事を拝見しました。
生涯現役のソフトウェアエンジニアでありたい。IC（Individual Contributor）のキャリアパスがあると自覚するまで 10 年の軌跡
IC(Individual Contributor)というキャリアがあるのかというのと、記事中の主張から自分のキャリアについて振り返る様になりました。
これまでのキャリアは前述のようにかなり行きあたりばったりでしたが、その中にも不動となる主軸が 2 つありました。(中略)
1 つは「毎日楽しく開発したい」ということ。(中略)
もう 1 つの軸は「選択肢を常に複数確保する」ことです。(中略)
この「毎日楽しく開発したい」は、私がエンジニアになりたいと思った動機「楽しく(刺激的に)生きたい」に通じるものがあり、IC というキャリアないしはテクニカルスキルをあげることで自分の幸福につながるのかという気づきがありました。
遠回りのような近道のような、どちらとも言えないですが、自分で出した答えの１つが大学進学、それもコンピュータに関する学位を取得するということでした。
ここについては自分の中で消化しきれていない部分もあるので、別の記事で改めて振り返ることにします。
帝京大学に決めたのはそこまで時間がかからなかった フルタイムで働きながらコンピュータに関する学位が取得できる通信制大学は、調べた限りだと選択肢は限られました。
また、同じくエンジニアとして働きながら勉強されている方のブログが大変参考になりました。
帝京大学理工学部(通信教育課程)の社会人大学生 1 年目をふりかえる
帝京大学の通信教育課程の学生やってます
@gkzvoice さんには twitter でブログに関して質問させていただき、またアドバイスまでいただいたので感謝です。
入るまでの手続きなど 詳細な手続きは募集要項にあるので、ここでは所感を述べるだけにします。
調査書、成績表の発行を、所属していた専門学校に依頼する必要があるので、余裕を持って出願する 志望理由を記載する必要があるので、動機と抱負は棚卸ししてたほうがスムーズかも 2 年次編入について 今回 2 年次編入で出願することができました。</p></div><div class=card-footer><span class=float-left>May 31, 2022</span>
<a href=/posts/category/look-back-on/2022/05/31/go-to-the-teikyo-university/ class="float-right btn btn-outline-info btn-sm">Read</a></div></div></a></div><div class=post-card><a href=/posts/introduction/ class=post-card-link><div class=card><div class=card-head><img class=card-img-top src=/posts/introduction/hero.png alt="Hero Image"></div><div class=card-body><h5 class=card-title>Introduction</h5><p class="card-text post-summary">はじめまして！
このページでは、いくつか自己紹介をしたいと思います。
内容に関しては追って更新しますので、しばらくお待ちくださいませ。
※「待てないよ!早く知りたい!」という意見がありましたら、お気軽に Twitter にてご連絡ください。
備考 表紙イラスト：Loose Drawing</p></div><div class=card-footer><span class=float-left>May 5, 2022</span>
<a href=/posts/introduction/ class="float-right btn btn-outline-info btn-sm">Read</a></div></div></a></div><div class=post-card><a href=/posts/category/look-back-on/2021/ class=post-card-link><div class=card><div class=card-head><img class=card-img-top src=/posts/category/look-back-on/2021/hero.png alt="Hero Image"></div><div class=card-body><h5 class=card-title>2021年の振り返り</h5><p class="card-text post-summary">はじめに 今年のふりかえりをするために個人ブログを数ヶ月ぶりに更新しています。
しばらくぶりに拙ブログを見ていて、ぜんぜんメンテしてなかったや。。の反省を強く感じたので来年はアウトプットをもっともっと増やします！
2021/01 とくに話すトピックはありませんでした。
読んでた本 改訂 2 版 みんなの Go 言語
Go プログラミング実践入門　標準ライブラリでゼロから Web アプリを作る
2021/02 とくに話すトピックはありませんでした。
読んでた本 達人プログラマー ―熟達に向けたあなたの旅― 第 2 版 2021/03 このころから年内に引っ越しを考えはじめました。
部屋に不満はありませんでしたが、ぼんやりと中央線沿い(=東京の西側)がかっこいいというイメージをもっていたので一人でちょくちょく出向いていました。
主に、杉並区エリア(中野/高円寺/阿佐ヶ谷/荻窪)を中心にまわっていました。
特に、荻窪にある杉並アニメーションミュージアムは、展示も楽しく見れますが、ミュージアムが入っている杉並会館の雰囲気が抜群にいいのでおすすめです。
2021/04 転職しました。社会人４年目にして３社目になります。
前職と同じくサーバーサイドのポジションです。
前職では、コロナ以降フルリモートでしたが、転職後は週３出社になりました。
出社になってからは、ランチをメンバーと取るようになり、コミュニケーションが増えたのがメリットに感じました。
仕事に関して前職では主に、Java/Go/Node.js での開発を２年ほどしていましたが、転職直後は Ruby on Rails での開発がメインになりました。
はじめての Ruby と Rails ということもあり、メンバーにはだいぶお世話になりながらも、プライベートではおすすめの参考書をかたっぱしから読む生活をしていました。
読んでた本 プロを目指す人のための Ruby 入門 言語仕様からテスト駆動開発・デバッグ技法まで (Software Design plus シリーズ)
パーフェクト Ruby on Rails 【増補改訂版】 (Perfect series)</p></div><div class=card-footer><span class=float-left>December 31, 2021</span>
<a href=/posts/category/look-back-on/2021/ class="float-right btn btn-outline-info btn-sm">Read</a></div></div></a></div><div class=post-card><a href=/posts/category/development/2021/03/pragmatic-programmer/ class=post-card-link><div class=card><div class=card-head><img class=card-img-top src=/posts/category/development/2021/03/pragmatic-programmer/hero.png alt="Hero Image"></div><div class=card-body><h5 class=card-title>達人プログラマーとは</h5><p class="card-text post-summary">はじめに エンジニアとしてコードを書くようになって、もうすぐ２年というタイミングに差し掛かりました
心境の変化としては、がむしゃらに毎日のタスクを通して「動く」コードを書くことから、メンテナンスしやすいコードを意識することが多くなりました
「達人プログラマー」は、プログラマとして次のステップを踏み出そうというときにベストな一冊となっています
達人の哲学 ソフトウェアのエントロピーの話は心当たりがありすぎた
エントロピー とは、物理学の用語で「ある系における無秩序の度合い」のことで、 時間が経つたびにエントロピーは増大していく
ソフトウェアも同様に、時間が経つたびに無秩序になっていく
これを 割れ窓理論 というメカニズムで説明していたのもわかりやすかった
窓が１枚割れているのを長期間放置しておくと、それをメンテナンスする気力もなくなるマインドが 植え付けられて、最終的には建物全体が破壊されていく
ソフトウェアではこれを、悪い設計、誤った意思決定、質の悪いコードに見立てることができて、 放置しておくと潜在的なバグを生み出すことになりかねない
こういった「割れた窓」を発見したと同時に速やかに修復するべきだ、そして時間がなくてもコメントを 残すといった何らかのアクションをしてくださいと言った主張だった
茹でガエルの話は、ある程度精神的に余裕がないと気づくことが難しいと感じた
あっつあつの熱湯にカエルを放り込むとびっくりして飛び出してくるが、 常温の水にカエルを入れて段々と温度をあげていくと、カエルは気づかないまま茹で上がると言った話
要するに、いつもメタ認知を意識して行動しようということ
これは仕事に限らずしていきたい
達人のアプローチ 章前半のDRY 原則については膝を叩いて同意できるといった実感があった
また、曳光弾の考え方については目からウロコだった
複雑なシステムを構築していくときに、各機能を一つずつ作り込んでいくのではなく、各機能を最低限使えるようにするシンプルな箇所を探していくといった手法
シンプルな箇所に最初に取り組んでその他は後回しにする（未実装）というのは初心者視点では至らないと感じた
章後半のプロトタイプ、見積もりの話は現実でも問われることがあるものの、 実際に見積もりが大きく外れるような難しい設計をした経験がないということもあって実感が持てなかった
「言語の制約はそれを使う人の世界を制限する」 - ヴィトゲンシュタイン
毎回トピックの初めに、名言があってモチベーションが上がる
プログラミング言語に限らず、日常使っている日本語にも問題に対する考え方や コミュニケーションに対する考え方に影響を及ぼしているという構造主義的な話もあって興味深い
基本的なツール 「悩んでいる君、そしてその悩みの原因は他の誰でもない、君自身によるものだ」 ということを知るのはつらいものだ
- ソフォクレス
デバッグの最初の心構え → 「パニクるな」
妄想の達人 契約プログラミング(DbC) は素晴らしい
仕様を記述(契約)しておくことで、プログラマにバグになりかねないようなことをさせないプログラミングをする
トラッシュ（メチャクチャ）にするのではなく、クラッシュ（停止）させる
Go のif err != nilで毎回エラーチェックしてるのはこれに則っているのかなと思った。
確かにcatchで新しいエラーがくるたびに分類するのは怠い気もするかな、、
柳に雪折れなし 列車の衝突事故を例にして依存をわかりやすく説明している
１つのメソッドであまりにも多くのことをやろうとすると、 連結されている全ての車両に影響が及ぶように、メソッドと属性が影響を受ける
例)割引料金を算出するメソッドの中で、これらの操作を行う。
顧客の注文履歴を参照する 注文履歴から特定の注文オブジェクトを取得する 注文オブジェクトの総額を返す 総額から割引した値をオブジェクトにセットする 次のような考え方がある</p></div><div class=card-footer><span class=float-left>March 5, 2021</span>
<a href=/posts/category/development/2021/03/pragmatic-programmer/ class="float-right btn btn-outline-info btn-sm">Read</a></div></div></a></div><div class=post-card><a href=/posts/category/security/2021/01/oauth/ class=post-card-link><div class=card><div class=card-head><img class=card-img-top src=/posts/category/security/2021/01/oauth/hero.png alt="Hero Image"></div><div class=card-body><h5 class=card-title>OAuth について</h5><p class="card-text post-summary">はじめに バックエンドエンジニアのロードマップに沿ってエンジニアとしての自己肯定感を養うシリーズです。
OAuth とは ひとまず、一番分かりやすい OAuth の説明で大体の感覚がつかめますのでオススメです。
こちらでもざっくり説明させてもらうと、OAuth は複数のアプリを連携させるための仕組みです。
例えば、ブログの記事を更新した瞬間に、ブログから更新情報をツイートしたかったりする場合に使われます。
ただ、そのままツイートできるわけではなくて、ブログアプリがツイートする許可(認可)をしてあげる必要があります。
そして許可されたアプリは許可証(アクセストークン)を持っていることで、Twitter を使ってツイートできるという仕組みです。
メリット OAuth を使うことで、上の例であげたブログアプリは、Twitter のユーザ名とパスワードを知らなくてもツイートできるという点です。
巷のアプリはこれを使うことで、Google アカウントや Twitter など SNS アカウントを持っているだけでユーザ登録できちゃいます。最初の煩わしい登録の手間が省けて良いです。
OAuth1.0 OAuth の初期バージョンです。他に 1.0a という名前のバージョンもありますが、Twitter では 1.0a を使うことができるみたいです。 (後述の 2.0 も同様に使用可)
特徴としては、認証と署名を用いて実現される仕様でありますが、実装が複雑で使用する言語が限られてしまうというデメリット?があるみたいです。(堅牢ではあると思いますが)
また、1.0 は Web アプリのみ対応しているので、デスクトップ/モバイルアプリは蚊帳の外とこれまた制限されるみたいです。
(Twitter は Web アプリ以外でも使える xAuth という OAuth 拡張を開発したりしてたみたいです)
さらに悲しいことに、1.0 の仕様は次の 2.0 の策定を持って廃止されたみたいです。
OAuth2.0 後継です。複雑と言われていた署名(とトークン交換)をバッサリ省いています。
これによって実装しやすいものになりましたがセキュリティが気になるところです。
OAuth 1.0 のほうが OAuth 2.0 より安全なの？でも言われている通り、2.0 はクライアントアプリケーションの幅が広がった分、秘密鍵の隠蔽が難しくなるみたいです。。
隠蔽できるかの違いはありますが、セキュリティレベルは両者それほど変わらないみたいです。
(2.0 は経路を TLS 化していることで、1.0 よりも提示するパラメータが少なくなっているという事実はあるそうな)
まとめ 実装のことを考えてこれからも 2.0 を使っていきましょうという締めです。</p></div><div class=card-footer><span class=float-left>January 5, 2021</span>
<a href=/posts/category/security/2021/01/oauth/ class="float-right btn btn-outline-info btn-sm">Read</a></div></div></a></div><div class=post-card><a href=/posts/category/system-design/2020/12/principles-of-the-systems-architecture/part1/ class=post-card-link><div class=card><div class=card-head><img class=card-img-top src=/posts/category/system-design/2020/12/principles-of-the-systems-architecture/part1/hero.png alt="Hero Image"></div><div class=card-body><h5 class=card-title>システム設計-part1-</h5><p class="card-text post-summary">はじめに バックエンドエンジニアのロードマップに沿ってエンジニアとしての自己肯定感を養うシリーズです。
※現場で役立つシステム設計の原則を元に記事を作成しています。
設計パターン 値オブジェクト(Value Object) Java で変数を扱うとき、int や String などで型定義しがちな初心者丸出しの実装をしていた私ですが、値オブジェクトを知ったとき眼からウロコでした。
値オブジェクトとは、汎用的な型(int や String)で型を定義するのではなく、専用の型(クラスやインターフェース)を定義します。
範囲の広い汎用的な型を使うのではなく、業務に合わせた値で制限するというものです。
値オブジェクトクラスはこんなかんじ
class Quantity { static final int MIN = 1; static final int MAX = 100; int value; Quantity(int value) { if (value &lt; MIN) { throw new IllegalArgumentException("不正" + MIN + "未満"); } if (value > MAX) { throw new IllegalArgumentException("不正" + MAX + "超"); } this.value = value; } } そして参照はこんなかんじ
Quantity quantity = new Quantity(50); こうすることで Quantity 型は値の制限(0~100)付きの実装ができるので安全です。</p></div><div class=card-footer><span class=float-left>December 5, 2020</span>
<a href=/posts/category/system-design/2020/12/principles-of-the-systems-architecture/part1/ class="float-right btn btn-outline-info btn-sm">Read</a></div></div></a></div><div class=post-card><a href=/posts/category/system-design/2020/12/principles-of-the-systems-architecture/part2/ class=post-card-link><div class=card><div class=card-head><img class=card-img-top src=/posts/category/system-design/2020/12/principles-of-the-systems-architecture/part2/hero.png alt="Hero Image"></div><div class=card-body><h5 class=card-title>システム設計-part2-</h5><p class="card-text post-summary">はじめに バックエンドエンジニアのロードマップに沿ってエンジニアとしての自己肯定感を養うシリーズです。
※現場で役立つシステム設計の原則を元に記事を作成しています。
設計パターン 早期リターン 複雑になりがちな場合分けのロジックの見通しをよくしようというものです。
ありがちなif-elseをつなげた(例 1)
Yen fee() { Yen result; if (isChild()) { result = chidFee(); } else if (isSenior()) { result = seniorFee(); } else { result = adultFee(); } return result; } さっきのコードからローカル変数を抜いて結果をすぐにreturnするようにした(例 2)
Yen fee() { if (isChild()) { return chidFee(); } else if (isSenior()) { return seniorFee(); } else { return adultFee(); } } このように、値が決まるとすぐにreturnするやり方を早期リターンと言います。
ガード節 上記の例 2 からelseを抜いた(例 3)
Yen fee() { if (isChild()) return chidFee(); if (isSenior()) return seniorFee(); return adultFee(); } elseを抜いた早期リターンをガード節と言います。非常にコンパクトですね。</p></div><div class=card-footer><span class=float-left>December 5, 2020</span>
<a href=/posts/category/system-design/2020/12/principles-of-the-systems-architecture/part2/ class="float-right btn btn-outline-info btn-sm">Read</a></div></div></a></div><div class=post-card><a href=/posts/category/system-design/2020/12/principles-of-the-systems-architecture/part3/ class=post-card-link><div class=card><div class=card-head><img class=card-img-top src=/posts/category/system-design/2020/12/principles-of-the-systems-architecture/part3/hero.png alt="Hero Image"></div><div class=card-body><h5 class=card-title>システム設計-part3-</h5><p class="card-text post-summary">はじめに バックエンドエンジニアのロードマップに沿ってエンジニアとしての自己肯定感を養うシリーズです。
※現場で役立つシステム設計の原則を元に記事を作成しています。
業務ロジック メソッドをロジックの置き場所にする 現場で役立つシステム設計の原則では、&ldquo;従来"という表現をされていますが、手続き型と呼ばれている設計ではデータクラスと機能クラスに分けて表現します。
その名の通りデータクラスはデータを格納して、機能クラスはデータクラスのデータを判断、加工、計算するといった使い方です。
この手続き型の問題は、拡張するときの変更箇所の特定に時間がかかるということです。
なぜかというと、データクラスが参照できるクラスであれば、アーキテクチャのどのレイヤーにでもロジックが書けてしまうからです。
便利のようには見えますが、先に言った変更箇所の特定に時間がかかるこの方法は最善ではありません。
解決としては、Java 本来のクラスの使い方を踏襲することです。
データとロジックを 1 つのクラスに閉じてしまおうという考え方です。
class PersonName { private String firstName; private String lastName; String fullName() { return String.format("%s %s", firstName, lastName); } } データであるfirstNameとlastName、そしてロジック(メソッド)のfullName()が同じクラス内にあります。
こうするとクラス内でデータを扱うことができて変更もこのクラス内で閉じることができます。
また、メソッドはクラス内のインスタンス変数(firstNameやlastName)を使って何らかの処理を行う用途で作成します。
クラスが肥大化したら小さく分ける これもやってしまいがちですが、改修を繰り返していくうちに、クラスが大きくなっていきます。
大きくなったクラスは手続き型同様に変更箇所の特定に時間がかかります。
それを防ぐために、大きくなってしまったクラスを次のルールで細分化します。
インスタンス変数とメソッドを対応付ける メソッドが全てのインスタンス変数を使うようになる 細分化したクラスはそれぞれ独立性が高くなるので、別のクラスで使う時にも再利用ができるようになります。
こうした関連の強いデータとロジックをまとめたクラスを凝集度が高いと言います。
凝集度が高いクラスは、変更箇所もそのクラスに閉じることになるので、疎結合になり他への影響が少なくて済みます。
まとめ 時すでに遅しと言いますか、現場での反省点をつらつら振り返ってベストプラクティスを学んでいるという感じです。
次回に活かそうというモチベーションは上がるのでいい復習方法だと感じます。
備考 現場で役立つシステム設計の原則
表紙イラスト：Loose Drawing</p></div><div class=card-footer><span class=float-left>December 5, 2020</span>
<a href=/posts/category/system-design/2020/12/principles-of-the-systems-architecture/part3/ class="float-right btn btn-outline-info btn-sm">Read</a></div></div></a></div><div class=post-card><a href=/posts/category/computer-science/2020/11/thread-and-concurrency/ class=post-card-link><div class=card><div class=card-head><img class=card-img-top src=/posts/category/computer-science/2020/11/thread-and-concurrency/hero.png alt="Hero Image"></div><div class=card-body><h5 class=card-title>スレッドと並行処理</h5><p class="card-text post-summary">はじめに バックエンドエンジニアのロードマップに沿ってエンジニアとしての自己肯定感を養うシリーズです。
スレッド プロセスが最低１つは持っている実行単位のことです。
こんな言い方をするのは、プロセスが複数のスレッドを管理できるからです。
実行単位という視点でプロセスとの違いは、「アドレス空間」を共有できるという点です。
尾を引くようにプロセス管理の話に繋がりますが、プロセスにはそれぞれ１つのアドレス空間が割り当てられます。
そして別のプロセスからアドレス空間へのアクセスは原則できません。(これを可能にするために共有メモリという方法を使います)
それに対して、スレッドは１つのプロセスの実行単位を分けたものですから、同じアドレス空間を共有できるというわけです。
そういうわけで、スレッドとプロセスをそれぞれ複数起動する場合は、スレッドの方がアドレス空間を１つで済ませることができるため省コストになります。
では、複数のスレッドを起動してやることは?というと並行処理です。
並行処理 これもすでに出てきている話ではあります。プロセス管理の記事で出した複数アプリを同時に起動させるという部分です。
「同時に」というのは私たちユーザがそう解釈しているだけで、アプリはカーネルが割り当てた非常に短い処理時間ごとに切り替えているのでしたよね。これが並行処理です。
スレッドでも同じように短い処理時間ごとに切り替えて「同時に」処理させることができます。
並列処理との違い 私自身、再三調べては納得 → 忘れるを繰り返していましたが、プロセス管理(3 度目)をまとめることでやっと理解できたと思います。
並行処理では処理時間ごとに切り替えると言いましたが、並列処理では CPU １つは言わず２つで処理してしまえばいいじゃないという考え方です。
図で見ると非常にわかりやすいのですが、並行処理だとパン食べてチーズ食べてハム食べてレタス食べて、、を繰り返して食べ切る作戦なのに対して、並列処理はミックスサンドとして食べ切るようなイメージです。
そんなの絶対ミックスサンドとして処理したら無限じゃんと思われますが、並列処理にも上限があるようです。
アムダールの法則といって複数のプロセッサ(CPU のことですね)を使って並列化による高速化を行う場合、そのプログラムの中で逐次的に実行される処理部分(並列)の時間によって、高速化が制限されるというものです。
出典：wikipedia「アムダールの法則」より引用
まあ、上限があるといっても高速するのに変わりはないわけです。
今回はその中でも比較的面白い実装を見つけたのでそれを紹介します。
ワーカープール スレッドプールとも呼ばれるものです。並行処理でたくさんのスレッドを起動して、、というのももちろん可能ですが、それには代償が伴います。
ワーカープールはそのようにいくつもスレッドを起動させるのではなく、すでに起動したスレッドを使い回そうの精神で実装される並行処理です。
以下のような実装です。
こちらを参考にさせていただきました。
(ほぼコメントつけただけですが)
package main import ( "fmt" "time" ) // 使い回し用のワーカー func worker(id int, jobs &lt;-chan int, results chan&lt;- int) { for j := range jobs { fmt.Println("worker", id, "started job", j) time.Sleep(time.Second) // 1秒待ち(重い処理を想定) fmt.</p></div><div class=card-footer><span class=float-left>October 5, 2020</span>
<a href=/posts/category/computer-science/2020/11/thread-and-concurrency/ class="float-right btn btn-outline-info btn-sm">Read</a></div></div></a></div><div class=post-card><a href=/posts/category/computer-science/2020/10/memory-management/ class=post-card-link><div class=card><div class=card-head><img class=card-img-top src=/posts/category/computer-science/2020/10/memory-management/hero.png alt="Hero Image"></div><div class=card-body><h5 class=card-title>メモリ管理</h5><p class="card-text post-summary">はじめに バックエンドエンジニアのロードマップに沿ってエンジニアとしての自己肯定感を養うシリーズです。
仮想メモリ プロセス管理でもあったように、メモリはアドレス空間ごとにプロセスを管理します。
アドレス空間は 4KB/8KB 単位のページに分割して管理されています。
ページはそれぞれ論理アドレス、物理アドレスを対応づける単位でもあります。
論理アドレスと物理アドレスは常に紐づけられているわけではなく、そのページが必要になった時点で割り当てることも可能です。
そのため、論理アドレスを実際の物理アドレスの容量より大きく確保することができます。
(実際に使えるメモリの量よりも大きなメモリを想定できるということです。)
仮装メモリとして使う仕組みには次の３つが挙げられます。
ページング 仮想メモリといえばこれ、という風に教えられるものの筆頭かと思います。
ハードディスクを物理メモリの代わりに使うといったものです。
物理メモリが不足すると、OS のコアであるカーネルは使われていないページをハードディスクに移して論理アドレスを解放します。
そしてプロセスがハードディスクに移されたページにアクセスしようとすると、カーネルがプロセスを停止し、ハードディスクのページを再度物理メモリに読み込み、論理アドレスを対応づけます。
また、プロセス全体を単位にする場合はスワッピングと呼ばれます。
メモリマップトファイル ファイルをメモリとしてアクセスすることができるものです。
アクセスがあった瞬間に、カーネルがファイルをメモリに読み込みます。プロセスがメモリを使い終わると、論理アドレスと物理アドレスを解放して、メモリの内容をファイルに保存します。
共有メモリ １つの物理アドレスを、複数のプロセスの論理アドレスに対応づけるものです。 アドレス空間をまたぐと危険では？！という見方もありますが、複数プロセスで処理できるため、巨大な画像データを編集するときには都合が良いみたいです。
※Go では共有メモリを使わずに Message Passing を使っています。
メモリ管理 API malloc(3) メモリをヒープ領域に割り当てます。プログラム実行時に決まるサイズのメモリはヒープ領域から確保します。
ヒープは「何かを積み重ねた山」のことで、その名の通り、プログラムを実行してから決定する量だけメモリを確保しておく領域なので納得です。
malloc で確保したメモリはfreeで解放しなければいけません。
calloc(3) メモリをヒープ領域に割り当てます。malloc と異なる点は、割り当てたメモリをゼロクリアすることです。
こちらも malloc 同様、確保したメモリはfreeで解放しなければいけません。
realloc(3) malloc で割り当てたメモリのサイズを拡大、縮小します。こちらも確保したメモリはfreeで解放しなければいけません。
free 割り当てたメモリを開放します。いったん開放したアドレスにはアクセスしてはいけません。
メモリの開放漏れを防ぐために、malloc で確保したメモリは常に free で開放されるべきです。
brk(2) malloc や realloc が割り当てるためのメモリを探してくるものです。
物理アドレスが割り当てられていないページに物理アドレスを対応づけます。
余談 メモリはエラーでもかなりお世話になる部分なので、次回以降、実際のエラーやプログラミング言語(Go か Java)に絡めた記事を書きたいです。
備考 ふつうの Linux プログラミング 第 2 版 Linux の仕組みから学べる gcc プログラミングの王道</p></div><div class=card-footer><span class=float-left>October 5, 2020</span>
<a href=/posts/category/computer-science/2020/10/memory-management/ class="float-right btn btn-outline-info btn-sm">Read</a></div></div></a></div><div class=post-card><a href=/posts/category/oss/2020/08/semantic-versioning/ class=post-card-link><div class=card><div class=card-head><img class=card-img-top src=/posts/category/oss/2020/08/semantic-versioning/hero.png alt="Hero Image"></div><div class=card-body><h5 class=card-title>Semantic Versioning</h5><p class="card-text post-summary">はじめに バックエンドエンジニアのロードマップに沿ってエンジニアとしての自己肯定感を養うシリーズです。
セマンティックバージョニング？ アプリに振るバージョン番号をSemVerというルールに従って付与しましょうというものです。
確かにバージョン番号に意味を持たせることで、ユーザからもアプリのバージョン番号が上がればバグ修正なのか機能追加なのかわかりますし、プログラムからも互換性を考慮して処理を分けることができるのでよいですね。
これだけ覚えておけば OK バージョン番号の形式は、メジャー.マイナー.パッチです。(例：1.0.0)
メジャー 後方互換性がない変更があった時にはこの番号を上げなければいけません(MUST) この番号を上げた際には、マイナー/パッチの番号は 0 にリセットしなければいけません(MUST) この番号が「0」の場合は初期開発用として扱います。リリースの段階でこの番号を「1」に上げます。 マイナー 後方互換性を保ちつつ、機能追加のある時にはこの番号を上げなければいけません(MUST) この番号を上げた際には、パッチの番号は 0 にリセットしなければいけません(MUST) パッチ 後方互換性を保ちつつ、バグ修正のある時にはこの番号を上げなければいけません(MUST) ※バグ修正とは間違った振る舞いを修正する内部の変更のことをいいます。
ちょっと踏み込むと プレリリースバージョンには、パッチ番号の後ろにハイフンで区切って識別子をつけることができます。 (例：1.1.0-alpha / 1.1.0-beta / 1.1.0-rc) ※ちなみに識別子のrcは「release candidate」の略でベータ版よりもさらに製品版に近い品質のバージョンにつけるそうです。（略を初めて知りました。）
あと npm の packagge.json でもモジュールをセマンティックバージョンで管理してます。（~や^が付与されているのをよく見ると思います。） これについては上、真ん中、下で覚えるバージョニング範囲指定がわかりやすかったので共有しておきます。
余談 たかがバージョニング、されどバージョニングといった感じでした。知ってて損はないですよね。
備考 表紙イラスト：Loose Drawing</p></div><div class=card-footer><span class=float-left>August 5, 2020</span>
<a href=/posts/category/oss/2020/08/semantic-versioning/ class="float-right btn btn-outline-info btn-sm">Read</a></div></div></a></div></div><div class=paginator><ul class=pagination><li class=page-item><a href=/posts/ class=page-link aria-label=First><span aria-hidden=true>&#171;&#171;</span></a></li><li class="page-item disabled"><a class=page-link aria-label=Previous><span aria-hidden=true>&#171;</span></a></li><li class="page-item active"><a class=page-link href=/posts/>1</a></li><li class=page-item><a class=page-link href=/posts/page/2/>2</a></li><li class=page-item><a href=/posts/page/2/ class=page-link aria-label=Next><span aria-hidden=true>&#187;</span></a></li><li class=page-item><a href=/posts/page/2/ class=page-link aria-label=Last><span aria-hidden=true>&#187;&#187;</span></a></li></ul></div></div></section></div><footer id=footer class="container-fluid text-center align-content-center footer pb-2"><div class="container pt-5"><div class="row text-left"><div class="col-md-4 col-sm-12"><h5>Navigation</h5><ul><li class=nav-item><a class=smooth-scroll href=https://uh-zz.github.io/#about>About</a></li><li class=nav-item><a class=smooth-scroll href=https://uh-zz.github.io/#skills>Skills</a></li><li class=nav-item><a class=smooth-scroll href=https://uh-zz.github.io/#experiences>Experiences</a></li><li class=nav-item><a class=smooth-scroll href=https://uh-zz.github.io/#education>Education</a></li><li class=nav-item><a class=smooth-scroll href=https://uh-zz.github.io/#projects>Projects</a></li><li class=nav-item><a class=smooth-scroll href=https://uh-zz.github.io/#recent-posts>Recent Posts</a></li></ul></div><div class="col-md-4 col-sm-12"><h5>Contact me:</h5><ul><li><a href=mailto:uhzz.contact@gmail.com target=_blank rel=noopener><span><i class="fas fa-envelope"></i></span><span>uhzz.contact@gmail.com</span></a></li></ul></div></div></div><hr><div class=container><div class="row text-left"><div class=col-md-4><a id=theme href=https://github.com/hossainemruz/toha target=_blank rel=noopener><img src=/images/theme-logo_hu8376fd15465fef26ffe66b6bcf0ca686_13669_32x0_resize_box_2.png alt="Toha Theme Logo">
Toha</a></div><div class="col-md-4 text-center">© 2022 Copyright.</div><div class="col-md-4 text-right"><a id=hugo href=https://gohugo.io/ target=_blank rel=noopener>Powered by
<img src=/images/hugo-logo.svg alt="Hugo Logo" height=18></a></div></div></div></footer><script type=text/javascript src=/js/jquery-3.4.1.min.js></script><script type=text/javascript src=/js/popper.min.js></script><script type=text/javascript src=/js/bootstrap.min.js></script><script type=text/javascript src=/js/navbar.js></script><script type=text/javascript src=/js/plyr.js></script><script type=text/javascript src=/js/main.js></script><script src=/js/list.js></script></body></html>