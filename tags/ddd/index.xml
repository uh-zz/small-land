<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ddd on small land</title><link>https://uh-zz.github.io/tags/ddd/</link><description>Recent content in ddd on small land</description><generator>Hugo -- gohugo.io</generator><language>jp</language><lastBuildDate>Sat, 05 Dec 2020 18:07:06 +0900</lastBuildDate><atom:link href="https://uh-zz.github.io/tags/ddd/index.xml" rel="self" type="application/rss+xml"/><item><title>システム設計-part1-</title><link>https://uh-zz.github.io/posts/category/system-design/2020/12/principles-of-the-systems-architecture/part1/</link><pubDate>Sat, 05 Dec 2020 18:07:06 +0900</pubDate><guid>https://uh-zz.github.io/posts/category/system-design/2020/12/principles-of-the-systems-architecture/part1/</guid><description>はじめに バックエンドエンジニアのロードマップに沿ってエンジニアとしての自己肯定感を養うシリーズです。
※現場で役立つシステム設計の原則を元に記事を作成しています。
設計パターン 値オブジェクト(Value Object) Java で変数を扱うとき、int や String などで型定義しがちな初心者丸出しの実装をしていた私ですが、値オブジェクトを知ったとき眼からウロコでした。
値オブジェクトとは、汎用的な型(int や String)で型を定義するのではなく、専用の型(クラスやインターフェース)を定義します。
範囲の広い汎用的な型を使うのではなく、業務に合わせた値で制限するというものです。
値オブジェクトクラスはこんなかんじ
class Quantity { static final int MIN = 1; static final int MAX = 100; int value; Quantity(int value) { if (value &amp;lt; MIN) { throw new IllegalArgumentException(&amp;quot;不正&amp;quot; + MIN + &amp;quot;未満&amp;quot;); } if (value &amp;gt; MAX) { throw new IllegalArgumentException(&amp;quot;不正&amp;quot; + MAX + &amp;quot;超&amp;quot;); } this.value = value; } } そして参照はこんなかんじ
Quantity quantity = new Quantity(50); こうすることで Quantity 型は値の制限(0~100)付きの実装ができるので安全です。</description></item><item><title>システム設計-part2-</title><link>https://uh-zz.github.io/posts/category/system-design/2020/12/principles-of-the-systems-architecture/part2/</link><pubDate>Sat, 05 Dec 2020 18:07:06 +0900</pubDate><guid>https://uh-zz.github.io/posts/category/system-design/2020/12/principles-of-the-systems-architecture/part2/</guid><description>はじめに バックエンドエンジニアのロードマップに沿ってエンジニアとしての自己肯定感を養うシリーズです。
※現場で役立つシステム設計の原則を元に記事を作成しています。
設計パターン 早期リターン 複雑になりがちな場合分けのロジックの見通しをよくしようというものです。
ありがちなif-elseをつなげた(例 1)
Yen fee() { Yen result; if (isChild()) { result = chidFee(); } else if (isSenior()) { result = seniorFee(); } else { result = adultFee(); } return result; } さっきのコードからローカル変数を抜いて結果をすぐにreturnするようにした(例 2)
Yen fee() { if (isChild()) { return chidFee(); } else if (isSenior()) { return seniorFee(); } else { return adultFee(); } } このように、値が決まるとすぐにreturnするやり方を早期リターンと言います。
ガード節 上記の例 2 からelseを抜いた(例 3)
Yen fee() { if (isChild()) return chidFee(); if (isSenior()) return seniorFee(); return adultFee(); } elseを抜いた早期リターンをガード節と言います。非常にコンパクトですね。</description></item><item><title>システム設計-part3-</title><link>https://uh-zz.github.io/posts/category/system-design/2020/12/principles-of-the-systems-architecture/part3/</link><pubDate>Sat, 05 Dec 2020 18:07:06 +0900</pubDate><guid>https://uh-zz.github.io/posts/category/system-design/2020/12/principles-of-the-systems-architecture/part3/</guid><description>はじめに バックエンドエンジニアのロードマップに沿ってエンジニアとしての自己肯定感を養うシリーズです。
※現場で役立つシステム設計の原則を元に記事を作成しています。
業務ロジック メソッドをロジックの置き場所にする 現場で役立つシステム設計の原則では、&amp;ldquo;従来&amp;quot;という表現をされていますが、手続き型と呼ばれている設計ではデータクラスと機能クラスに分けて表現します。
その名の通りデータクラスはデータを格納して、機能クラスはデータクラスのデータを判断、加工、計算するといった使い方です。
この手続き型の問題は、拡張するときの変更箇所の特定に時間がかかるということです。
なぜかというと、データクラスが参照できるクラスであれば、アーキテクチャのどのレイヤーにでもロジックが書けてしまうからです。
便利のようには見えますが、先に言った変更箇所の特定に時間がかかるこの方法は最善ではありません。
解決としては、Java 本来のクラスの使い方を踏襲することです。
データとロジックを 1 つのクラスに閉じてしまおうという考え方です。
class PersonName { private String firstName; private String lastName; String fullName() { return String.format(&amp;quot;%s %s&amp;quot;, firstName, lastName); } } データであるfirstNameとlastName、そしてロジック(メソッド)のfullName()が同じクラス内にあります。
こうするとクラス内でデータを扱うことができて変更もこのクラス内で閉じることができます。
また、メソッドはクラス内のインスタンス変数(firstNameやlastName)を使って何らかの処理を行う用途で作成します。
クラスが肥大化したら小さく分ける これもやってしまいがちですが、改修を繰り返していくうちに、クラスが大きくなっていきます。
大きくなったクラスは手続き型同様に変更箇所の特定に時間がかかります。
それを防ぐために、大きくなってしまったクラスを次のルールで細分化します。
インスタンス変数とメソッドを対応付ける メソッドが全てのインスタンス変数を使うようになる 細分化したクラスはそれぞれ独立性が高くなるので、別のクラスで使う時にも再利用ができるようになります。
こうした関連の強いデータとロジックをまとめたクラスを凝集度が高いと言います。
凝集度が高いクラスは、変更箇所もそのクラスに閉じることになるので、疎結合になり他への影響が少なくて済みます。
まとめ 時すでに遅しと言いますか、現場での反省点をつらつら振り返ってベストプラクティスを学んでいるという感じです。
次回に活かそうというモチベーションは上がるのでいい復習方法だと感じます。</description></item></channel></rss>